
/***********************************************************************

Copyright 2017 quantOS-org

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at:

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

***********************************************************************/
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: jzs.proto

#ifndef PROTOBUF_jzs_2eproto__INCLUDED
#define PROTOBUF_jzs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace jzs {
namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_jzs_2eproto();
void protobuf_AssignDesc_jzs_2eproto();
void protobuf_ShutdownFile_jzs_2eproto();

class MsgHead;
class Msg;
class SysTimer;
class SysInit;

enum MsgType {
  MSG_SYS_INIT = 0,
  MSG_SYS_TIMER = 1,
  MSG_LOW_HEARTBEAT_REQ = 2,
  MSG_LOW_HEARTBEAT_RSP = 3,
  MSG_TD_ORDER_REQ = 10,
  MSG_TD_ORDER_RSP = 11,
  MSG_TD_ORDER_REPORT_IND = 12,
  MSG_TD_QUERY_ACCOUNT_REQ = 13,
  MSG_TD_QUERY_ACCOUNT_RSP = 14,
  MSG_TD_QUERY_POSITION_REQ = 15,
  MSG_TD_QUERY_POSITION_RSP = 16,
  MSG_TD_CANCEL_ORDER_REQ = 17,
  MSG_TD_CANCEL_ORDER_RSP = 18,
  MSG_TD_QUERY_TRADE_REQ = 80,
  MSG_TD_QUERY_TRADE_RSP = 81,
  MSG_QMS_MARKETQUOTE_REQ = 20,
  MSG_QMS_MARKETQUOTE_RSP = 21,
  MSG_QMS_BAR_1M_REQ = 22,
  MSG_QMS_BAR_1M_RSP = 23,
  MSG_QMS_STRATEGY_MARKETQUOTES_REQ = 24,
  MSG_QMS_STRATEGY_MARKETQUOTES_RSP = 25,
  MSG_QMS_STRATEGY_SUBSCRIBE_REQ = 26,
  MSG_QMS_STRATEGY_SUBSCRIBE_RSP = 27,
  MSG_MD_MARKETDATA_IND = 31,
  MSG_OMS_GOAL_PORTFOLIO_REQ = 40,
  MSG_OMS_GOAL_PORTFOLIO_RSP = 41,
  MSG_OMS_QUERY_PORTFOLIO_REQ = 42,
  MSG_OMS_QUERY_PORTFOLIO_RSP = 43,
  MSG_OMS_SET_PANIC_REQ = 44,
  MSG_OMS_SET_PANIC_RSP = 45,
  MSG_OMS_SYNC_ACCOUNT_REQ = 46,
  MSG_OMS_SYNC_ACCOUNT_RSP = 47,
  MSG_OMS_QUERY_ACCOUNT_REQ = 48,
  MSG_OMS_QUERY_ACCOUNT_RSP = 49,
  MSG_OMS_BASKET_ORDER_REQ = 70,
  MSG_OMS_BASKET_ORDER_RSP = 71,
  MSG_OMS_STOP_PORTFOLIO_REQ = 72,
  MSG_OMS_STOP_PORTFOLIO_RSP = 73,
  MSG_EMS_ORDER_REQ = 50,
  MSG_EMS_ORDER_RSP = 51,
  MSG_EMS_ORDER_REPORT_IND = 52,
  MSG_EMS_CANCEL_ORDER_REQ = 53,
  MSG_EMS_CANCEL_ORDER_RSP = 54,
  MSG_MISC_GET_TDTICKET_REQ = 60,
  MSG_MISC_GET_TDTICKET_RSP = 61,
  MSG_MISC_SELF_MESSAGE = 62,
  MSG_TRANS_TRANSACTION = 91,
  MSG_TRANS_GET_TRANSACTION_REQ = 92,
  MSG_TRANS_GET_TRANSACTION_RSP = 93,
  MSG_ORDER_ORDER = 94,
  MSG_ORDER_GET_ORDER_REQ = 95,
  MSG_ORDER_GET_ORDER_RSP = 96
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_SYS_INIT;
const MsgType MsgType_MAX = MSG_ORDER_GET_ORDER_RSP;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class MsgHead : public ::google::protobuf::Message {
 public:
  MsgHead();
  virtual ~MsgHead();

  MsgHead(const MsgHead& from);

  inline MsgHead& operator=(const MsgHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgHead& default_instance();

  void Swap(MsgHead* other);

  // implements Message ----------------------------------------------

  MsgHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgHead& from);
  void MergeFrom(const MsgHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 tid = 1;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // required string src = 2;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 2;
  inline const ::std::string& src() const;
  inline void set_src(const ::std::string& value);
  inline void set_src(const char* value);
  inline void set_src(const char* value, size_t size);
  inline ::std::string* mutable_src();
  inline ::std::string* release_src();
  inline void set_allocated_src(::std::string* src);

  // required string dst = 3;
  inline bool has_dst() const;
  inline void clear_dst();
  static const int kDstFieldNumber = 3;
  inline const ::std::string& dst() const;
  inline void set_dst(const ::std::string& value);
  inline void set_dst(const char* value);
  inline void set_dst(const char* value, size_t size);
  inline ::std::string* mutable_dst();
  inline ::std::string* release_dst();
  inline void set_allocated_dst(::std::string* dst);

  // optional bool compressed = 4;
  inline bool has_compressed() const;
  inline void clear_compressed();
  static const int kCompressedFieldNumber = 4;
  inline bool compressed() const;
  inline void set_compressed(bool value);

  // @@protoc_insertion_point(class_scope:jzs.msg.MsgHead)
 private:
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_dst();
  inline void clear_has_dst();
  inline void set_has_compressed();
  inline void clear_has_compressed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* src_;
  ::google::protobuf::uint32 tid_;
  bool compressed_;
  ::std::string* dst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_jzs_2eproto();
  friend void protobuf_AssignDesc_jzs_2eproto();
  friend void protobuf_ShutdownFile_jzs_2eproto();

  void InitAsDefaultInstance();
  static MsgHead* default_instance_;
};
// -------------------------------------------------------------------

class Msg : public ::google::protobuf::Message {
 public:
  Msg();
  virtual ~Msg();

  Msg(const Msg& from);

  inline Msg& operator=(const Msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg& default_instance();

  void Swap(Msg* other);

  // implements Message ----------------------------------------------

  Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg& from);
  void MergeFrom(const Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .jzs.msg.MsgHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::jzs::msg::MsgHead& head() const;
  inline ::jzs::msg::MsgHead* mutable_head();
  inline ::jzs::msg::MsgHead* release_head();
  inline void set_allocated_head(::jzs::msg::MsgHead* head);

  // required bytes body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const void* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:jzs.msg.Msg)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::jzs::msg::MsgHead* head_;
  ::std::string* body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_jzs_2eproto();
  friend void protobuf_AssignDesc_jzs_2eproto();
  friend void protobuf_ShutdownFile_jzs_2eproto();

  void InitAsDefaultInstance();
  static Msg* default_instance_;
};
// -------------------------------------------------------------------

class SysTimer : public ::google::protobuf::Message {
 public:
  SysTimer();
  virtual ~SysTimer();

  SysTimer(const SysTimer& from);

  inline SysTimer& operator=(const SysTimer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysTimer& default_instance();

  void Swap(SysTimer* other);

  // implements Message ----------------------------------------------

  SysTimer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysTimer& from);
  void MergeFrom(const SysTimer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 interval = 2;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 interval() const;
  inline void set_interval(::google::protobuf::uint32 value);

  // required int64 data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline ::google::protobuf::int64 data() const;
  inline void set_data(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:jzs.msg.SysTimer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 interval_;
  ::google::protobuf::int64 data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_jzs_2eproto();
  friend void protobuf_AssignDesc_jzs_2eproto();
  friend void protobuf_ShutdownFile_jzs_2eproto();

  void InitAsDefaultInstance();
  static SysTimer* default_instance_;
};
// -------------------------------------------------------------------

class SysInit : public ::google::protobuf::Message {
 public:
  SysInit();
  virtual ~SysInit();

  SysInit(const SysInit& from);

  inline SysInit& operator=(const SysInit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysInit& default_instance();

  void Swap(SysInit* other);

  // implements Message ----------------------------------------------

  SysInit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysInit& from);
  void MergeFrom(const SysInit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jzs.msg.SysInit)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_jzs_2eproto();
  friend void protobuf_AssignDesc_jzs_2eproto();
  friend void protobuf_ShutdownFile_jzs_2eproto();

  void InitAsDefaultInstance();
  static SysInit* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgHead

// required fixed32 tid = 1;
inline bool MsgHead::has_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHead::set_has_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHead::clear_has_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHead::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 MsgHead::tid() const {
  return tid_;
}
inline void MsgHead::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// required string src = 2;
inline bool MsgHead::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHead::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHead::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHead::clear_src() {
  if (src_ != &::google::protobuf::internal::kEmptyString) {
    src_->clear();
  }
  clear_has_src();
}
inline const ::std::string& MsgHead::src() const {
  return *src_;
}
inline void MsgHead::set_src(const ::std::string& value) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgHead::set_src(const char* value) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgHead::set_src(const char* value, size_t size) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgHead::mutable_src() {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  return src_;
}
inline ::std::string* MsgHead::release_src() {
  clear_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_;
    src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgHead::set_allocated_src(::std::string* src) {
  if (src_ != &::google::protobuf::internal::kEmptyString) {
    delete src_;
  }
  if (src) {
    set_has_src();
    src_ = src;
  } else {
    clear_has_src();
    src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string dst = 3;
inline bool MsgHead::has_dst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgHead::set_has_dst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgHead::clear_has_dst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgHead::clear_dst() {
  if (dst_ != &::google::protobuf::internal::kEmptyString) {
    dst_->clear();
  }
  clear_has_dst();
}
inline const ::std::string& MsgHead::dst() const {
  return *dst_;
}
inline void MsgHead::set_dst(const ::std::string& value) {
  set_has_dst();
  if (dst_ == &::google::protobuf::internal::kEmptyString) {
    dst_ = new ::std::string;
  }
  dst_->assign(value);
}
inline void MsgHead::set_dst(const char* value) {
  set_has_dst();
  if (dst_ == &::google::protobuf::internal::kEmptyString) {
    dst_ = new ::std::string;
  }
  dst_->assign(value);
}
inline void MsgHead::set_dst(const char* value, size_t size) {
  set_has_dst();
  if (dst_ == &::google::protobuf::internal::kEmptyString) {
    dst_ = new ::std::string;
  }
  dst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgHead::mutable_dst() {
  set_has_dst();
  if (dst_ == &::google::protobuf::internal::kEmptyString) {
    dst_ = new ::std::string;
  }
  return dst_;
}
inline ::std::string* MsgHead::release_dst() {
  clear_has_dst();
  if (dst_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dst_;
    dst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgHead::set_allocated_dst(::std::string* dst) {
  if (dst_ != &::google::protobuf::internal::kEmptyString) {
    delete dst_;
  }
  if (dst) {
    set_has_dst();
    dst_ = dst;
  } else {
    clear_has_dst();
    dst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool compressed = 4;
inline bool MsgHead::has_compressed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgHead::set_has_compressed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgHead::clear_has_compressed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgHead::clear_compressed() {
  compressed_ = false;
  clear_has_compressed();
}
inline bool MsgHead::compressed() const {
  return compressed_;
}
inline void MsgHead::set_compressed(bool value) {
  set_has_compressed();
  compressed_ = value;
}

// -------------------------------------------------------------------

// Msg

// required .jzs.msg.MsgHead head = 1;
inline bool Msg::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg::clear_head() {
  if (head_ != NULL) head_->::jzs::msg::MsgHead::Clear();
  clear_has_head();
}
inline const ::jzs::msg::MsgHead& Msg::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::jzs::msg::MsgHead* Msg::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::jzs::msg::MsgHead;
  return head_;
}
inline ::jzs::msg::MsgHead* Msg::release_head() {
  clear_has_head();
  ::jzs::msg::MsgHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void Msg::set_allocated_head(::jzs::msg::MsgHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// required bytes body = 2;
inline bool Msg::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& Msg::body() const {
  return *body_;
}
inline void Msg::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void Msg::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void Msg::set_body(const void* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* Msg::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SysTimer

// required uint32 id = 1;
inline bool SysTimer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysTimer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysTimer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysTimer::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SysTimer::id() const {
  return id_;
}
inline void SysTimer::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 interval = 2;
inline bool SysTimer::has_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysTimer::set_has_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysTimer::clear_has_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysTimer::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 SysTimer::interval() const {
  return interval_;
}
inline void SysTimer::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
}

// required int64 data = 3;
inline bool SysTimer::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysTimer::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysTimer::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysTimer::clear_data() {
  data_ = GOOGLE_LONGLONG(0);
  clear_has_data();
}
inline ::google::protobuf::int64 SysTimer::data() const {
  return data_;
}
inline void SysTimer::set_data(::google::protobuf::int64 value) {
  set_has_data();
  data_ = value;
}

// -------------------------------------------------------------------

// SysInit


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg
}  // namespace jzs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jzs::msg::MsgType>() {
  return ::jzs::msg::MsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_jzs_2eproto__INCLUDED
